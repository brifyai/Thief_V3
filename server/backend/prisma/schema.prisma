generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "darwin-arm64", "darwin", "linux-musl", "windows"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id               Int                  @id @default(autoincrement())
  email            String               @unique
  password         String
  name             String?
  role             String               @default("user")
  is_active        Boolean              @default(true)
  last_login       DateTime?
  created_at       DateTime             @default(now())
  updated_at       DateTime             @updatedAt
  ai_rewrites      ai_rewrites[]
  saved_urls       saved_urls[]
  scraping_results scraping_results[]
  scraping_stats   scraping_stats[]
  public_urls      PublicUrl[]
  url_selections   UserUrlSelection[]
  saved_articles   SavedArticle[]
  entities         Entity[]
  ai_usage_logs    AiUsageLog[]

  @@map("users")
}

model ai_rewrites {
  id                 Int               @id @default(autoincrement())
  user_id            Int
  saved_url_id       Int
  scraping_result_id Int?
  original_content   String            @db.Text
  rewritten_content  String            @db.Text
  ai_model           String
  prompt_used        String?           @db.Text
  tokens_used        Int?
  cost_estimate      Decimal?          @db.Decimal(10, 6)
  response_time      Int?
  success            Boolean           @default(true)
  error_message      String?           @db.Text
  created_at         DateTime          @default(now())
  saved_urls         saved_urls        @relation(fields: [saved_url_id], references: [id], onDelete: Cascade)
  scraping_results   scraping_results? @relation(fields: [scraping_result_id], references: [id])
  user               User              @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@index([user_id, created_at])
  @@index([success])
}

/// This model contains an expression index which requires additional setup for migrations. Visit https://pris.ly/d/expression-indexes for more info.
model saved_urls {
  id               Int                @id @default(autoincrement())
  user_id          Int
  url              String
  title            String?
  description      String?
  domain           String
  nombre           String?
  region           String?
  created_at       DateTime           @default(now())
  updated_at       DateTime           @updatedAt
  ai_rewrites      ai_rewrites[]
  user             User               @relation(fields: [user_id], references: [id], onDelete: Cascade)
  scraping_results scraping_results[]

  @@index([user_id, url])
  @@index([domain])
  @@index([region])
  @@index([user_id, domain])
}

/// This model contains an expression index which requires additional setup for migrations. Visit https://pris.ly/d/expression-indexes for more info.
model scraping_results {
  id              Int           @id @default(autoincrement())
  user_id         Int?          // üîπ OPCIONAL: null para scraping de URLs p√∫blicas
  saved_url_id    Int?          // üîπ OPCIONAL: para compatibilidad con URLs antiguas
  public_url_id   Int?          // üîπ NUEVO: referencia a PublicUrl
  
  // Campos de contenido
  title           String        @default("Sin t√≠tulo")  // T√≠tulo de la noticia (requerido con default)
  summary         String?       @db.Text                // Resumen corto (opcional)
  content         String        @db.Text                // Contenido completo original
  cleaned_content String        @db.Text                // Contenido limpio (requerido)
  
  // üîπ FASE 1: Detecci√≥n de duplicados
  content_hash    String?       @db.VarChar(64)         // Hash SHA-256 del contenido (para duplicados)
  
  // Metadatos de scraping
  scraping_type   String
  success         Boolean       @default(true)
  error_message   String?       @db.Text
  response_time   Int?
  status_code     Int?
  content_length  Int?
  
  // Categorizaci√≥n
  category        String?
  domain          String?
  region          String?
  
  // üîπ FASE 2: Tracking de fuente de t√≠tulo
  title_source    String?       @default("extracted")   // extracted, meta_tags, ai, fallback
  
  // üîπ FASE 3: Tracking de m√©todo de categorizaci√≥n
  categorization_method String?  @default("keywords")    // ai, url, domain, keywords, fallback
  categorization_confidence Float? @default(0.7)         // Confianza de la categorizaci√≥n (0-1)
  
  // üîπ FASE 4: M√©tricas de uso de IA
  ai_used         Boolean       @default(false)         // Si se us√≥ IA en este scraping
  ai_tokens_used  Int?                                  // Tokens consumidos (si aplica)
  
  // Timestamps
  created_at      DateTime      @default(now())
  scraped_at      DateTime?
  
  // Relaciones
  ai_rewrites     ai_rewrites[]
  saved_articles  SavedArticle[]
  entity_mentions EntityMention[]
  saved_urls      saved_urls?   @relation(fields: [saved_url_id], references: [id], onDelete: Cascade)
  public_url      PublicUrl?    @relation(fields: [public_url_id], references: [id], onDelete: Cascade)
  user            User?         @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@index([user_id, scraped_at])
  @@index([saved_url_id, scraped_at])
  @@index([public_url_id, scraped_at])
  @@index([category])
  @@index([domain])
  @@index([region])
  @@index([success])
  @@index([title])
  @@index([content_hash])                      // üîπ FASE 1: B√∫squeda r√°pida de duplicados
  @@index([ai_used, scraped_at])               // üîπ FASE 4: M√©tricas de uso de IA
  @@index([categorization_method])             // üîπ FASE 3: An√°lisis de m√©todos
}

model scraping_stats {
  id                    Int      @id @default(autoincrement())
  user_id               Int
  date                  DateTime @db.Date
  total_scrapes         Int      @default(0)
  successful_scrapes    Int      @default(0)
  failed_scrapes        Int      @default(0)
  total_ai_rewrites     Int      @default(0)
  total_tokens_used     Int      @default(0)
  total_cost_estimate   Decimal  @default(0) @db.Decimal(10, 6)
  average_response_time Int?
  created_at            DateTime @default(now())
  updated_at            DateTime @updatedAt
  user                  User     @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([user_id, date])
  @@index([date])
}

model SiteConfiguration {
  id               String    @id @default(cuid())
  domain           String    @unique
  name             String
  titleSelector    String
  contentSelector  String
  dateSelector     String?
  authorSelector   String?
  imageSelector    String?
  cleaningRules    Json?
  createdBy        String
  verifiedBy       String[]  @default([])
  usageCount       Int       @default(0)
  successCount     Int       @default(0)
  failureCount     Int       @default(0)
  confidence       Float     @default(0.5)
  isActive         Boolean   @default(true)
  isVerified       Boolean   @default(false)
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  listingSelectors Json?
  lastError        String?   @db.Text
  lastSuccess      DateTime?
  lastUsedAt       DateTime?

  @@index([domain])
  @@index([confidence])
  @@index([isActive])
  @@index([isVerified])
  @@index([createdBy])
  @@index([lastUsedAt])
  @@map("site_configurations")
}

// üîπ URLs globales (creadas por admin)
model PublicUrl {
  id               Int                @id @default(autoincrement())
  url              String             @unique
  name             String?
  domain           String
  region           String?
  is_active        Boolean            @default(true)
  
  // üÜï SISTEMA DE L√çMITE DE NOTICIAS
  max_news_limit        Int?           // L√≠mite de noticias a extraer (null = sin l√≠mite)
  available_news_count  Int?           // Noticias disponibles (del √∫ltimo test)
  last_tested_at        DateTime?      // √öltima vez que se prob√≥ la URL
  test_status           String?        // 'success', 'failed', 'pending'
  
  created_by       Int
  created_at       DateTime           @default(now())
  updated_at       DateTime           @updatedAt

  createdBy        User               @relation(fields: [created_by], references: [id], onDelete: Cascade)
  selections       UserUrlSelection[]
  scraping_results scraping_results[] // üîπ Relaci√≥n con resultados de scraping

  @@index([domain])
  @@index([is_active])
  @@index([created_by])
  @@index([test_status])
  @@map("public_urls")
}

// üîπ Suscripciones de usuarios (qu√© URLs siguen)
model UserUrlSelection {
  id            Int       @id @default(autoincrement())
  user_id       Int
  public_url_id Int
  created_at    DateTime  @default(now())

  user          User      @relation(fields: [user_id], references: [id], onDelete: Cascade)
  public_url    PublicUrl @relation(fields: [public_url_id], references: [id], onDelete: Cascade)

  @@unique([user_id, public_url_id])
  @@index([user_id])
  @@index([public_url_id])
  @@map("user_url_selections")
}

// üîπ Noticias guardadas/favoritas por usuario
model SavedArticle {
  id                 Int      @id @default(autoincrement())
  user_id            Int
  scraping_result_id Int?     // üîπ OPCIONAL: puede ser null si se elimin√≥ el original
  notes              String?  @db.Text
  tags               String[] @default([])
  is_read            Boolean  @default(false)
  
  // üîπ NUEVO: Contenido copiado para preservaci√≥n
  saved_title        String?
  saved_content      String?  @db.Text
  saved_summary      String?  @db.Text
  saved_domain       String?
  saved_category     String?
  saved_url          String?
  
  created_at         DateTime @default(now())
  updated_at         DateTime @updatedAt

  user               User             @relation(fields: [user_id], references: [id], onDelete: Cascade)
  scraping_result    scraping_results? @relation(fields: [scraping_result_id], references: [id], onDelete: SetNull)
  //                                                                                           ^^^^^^^^^^
  //                                                                                           ‚úÖ Solo desvincula, NO elimina

  @@unique([user_id, scraping_result_id])
  @@index([user_id, is_read])
  @@index([user_id, created_at])
  @@index([saved_domain])
  @@index([saved_category])
  @@map("saved_articles")
}

// ============================================
// üîç SISTEMA DE MONITOREO DE ENTIDADES
// ============================================

model Entity {
  id              String   @id @default(cuid())
  user_id         Int
  name            String
  aliases         String[] @default([])
  type            EntityType @default(PERSON)
  description     String?  @db.Text
  is_active       Boolean  @default(true)
  case_sensitive  Boolean  @default(false)
  exact_match     Boolean  @default(false)
  alert_enabled   Boolean  @default(true)
  alert_threshold Float    @default(0.2)
  
  // üÜï ENTITY ANALYZER V2
  analysis_context  String   @default("politica_chile")
  positive_phrases  String[] @default([])
  negative_phrases  String[] @default([])
  
  created_at      DateTime @default(now())
  updated_at      DateTime @updatedAt
  last_analyzed   DateTime?
  
  user            User     @relation(fields: [user_id], references: [id], onDelete: Cascade)
  mentions        EntityMention[]
  snapshots       EntitySnapshot[]
  alerts          EntityAlert[]
  
  @@index([user_id, is_active])
  @@index([name])
  @@index([type])
  @@index([analysis_context])
  @@map("entities")
}

model EntityMention {
  id                   String   @id @default(cuid())
  entity_id            String
  scraping_result_id   Int
  context              String   @db.Text
  position             Int
  prominence           Float    @default(0.5)
  sentiment            Sentiment
  sentiment_score      Float
  sentiment_confidence Float
  keywords             String[] @default([])
  topics               String[] @default([])
  tone                 String?
  
  // üÜï ENTITY ANALYZER V2
  reason               String?  @db.Text
  summary              String?  @db.Text
  analysis_method      String?  @default("ai")
  
  analyzed_at          DateTime @default(now())
  tokens_used          Int?
  
  entity               Entity   @relation(fields: [entity_id], references: [id], onDelete: Cascade)
  scraping_result      scraping_results @relation(fields: [scraping_result_id], references: [id], onDelete: Cascade)
  
  @@unique([entity_id, scraping_result_id])
  @@index([entity_id, analyzed_at])
  @@index([sentiment])
  @@index([scraping_result_id])
  @@index([analysis_method])
  @@map("entity_mentions")
}

model EntitySnapshot {
  id                  String   @id @default(cuid())
  entity_id           String
  date                DateTime @db.Date
  total_mentions      Int      @default(0)
  new_mentions        Int      @default(0)
  positive_count      Int      @default(0)
  negative_count      Int      @default(0)
  neutral_count       Int      @default(0)
  avg_sentiment       Float    @default(0)
  avg_confidence      Float    @default(0)
  top_keywords        Json
  top_sources         Json
  trend_direction     String?
  calculated_at       DateTime @default(now())
  
  entity              Entity   @relation(fields: [entity_id], references: [id], onDelete: Cascade)
  
  @@unique([entity_id, date])
  @@index([entity_id, date(sort: Desc)])
  @@index([date])
  @@map("entity_snapshots")
}

model EntityAlert {
  id          String   @id @default(cuid())
  entity_id   String
  type        AlertType
  severity    AlertSeverity @default(MEDIUM)
  title       String
  message     String   @db.Text
  data        Json
  is_read     Boolean  @default(false)
  created_at  DateTime @default(now())
  read_at     DateTime?
  
  entity      Entity   @relation(fields: [entity_id], references: [id], onDelete: Cascade)
  
  @@index([entity_id, created_at(sort: Desc)])
  @@index([is_read, severity])
  @@map("entity_alerts")
}

enum EntityType {
  PERSON
  COMPANY
  TOPIC
  EVENT
}

enum Sentiment {
  POSITIVE
  NEGATIVE
  NEUTRAL
  MIXED
}

enum AlertType {
  SENTIMENT_CHANGE
  VOLUME_SPIKE
  CRISIS_DETECTED
  TRENDING
}

enum AlertSeverity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

// ========================================
// MODELOS PARA TRACKING DE TOKENS IA
// ========================================

model AiUsageLog {
  id              Int      @id @default(autoincrement())
  operation_type  String   // 'search', 'sentiment', 'entity', 'clustering', etc.
  operation_id    String?  // ID de la operaci√≥n espec√≠fica
  user_id         Int?     // Usuario que inici√≥ la operaci√≥n
  
  // Tokens
  input_tokens    Int
  output_tokens   Int
  total_tokens    Int
  
  // Costos (en USD)
  input_cost      Float
  output_cost     Float
  total_cost      Float
  
  // Metadata
  model_used      String   // 'llama3-8b-8192', 'gpt-4', etc.
  prompt_length   Int?
  response_length Int?
  cache_hit       Boolean  @default(false)
  
  // Contexto
  endpoint        String?  // Endpoint que inici√≥ la llamada
  ip_address      String?
  user_agent      String?
  
  // Timing
  duration_ms     Int?     // Duraci√≥n de la llamada
  created_at      DateTime @default(now())
  
  // Relaciones
  user            User?    @relation(fields: [user_id], references: [id])
  
  @@index([operation_type])
  @@index([user_id])
  @@index([created_at])
  @@index([cache_hit])
  @@map("ai_usage_logs")
}

model AiUsageStats {
  id                    Int      @id @default(autoincrement())
  date                  DateTime @unique @db.Date // Fecha del d√≠a (sin hora)
  
  // Totales del d√≠a
  total_operations      Int      @default(0)
  total_tokens          Int      @default(0)
  total_cost            Float    @default(0)
  
  // Por tipo de operaci√≥n
  search_operations     Int      @default(0)
  search_tokens         Int      @default(0)
  search_cost           Float    @default(0)
  
  sentiment_operations  Int      @default(0)
  sentiment_tokens      Int      @default(0)
  sentiment_cost        Float    @default(0)
  
  entity_operations     Int      @default(0)
  entity_tokens         Int      @default(0)
  entity_cost           Float    @default(0)
  
  clustering_operations Int      @default(0)
  clustering_tokens     Int      @default(0)
  clustering_cost       Float    @default(0)
  
  synonym_operations    Int      @default(0)
  synonym_tokens        Int      @default(0)
  synonym_cost          Float    @default(0)
  
  pattern_operations    Int      @default(0)
  pattern_tokens        Int      @default(0)
  pattern_cost          Float    @default(0)
  
  other_operations      Int      @default(0)
  other_tokens          Int      @default(0)
  other_cost            Float    @default(0)
  
  // Cach√©
  cache_hits            Int      @default(0)
  cache_misses          Int      @default(0)
  cache_hit_rate        Float    @default(0)
  
  // Savings
  estimated_savings     Float    @default(0) // Ahorro por cach√©
  
  created_at            DateTime @default(now())
  updated_at            DateTime @updatedAt
  
  @@index([date])
  @@map("ai_usage_stats")
}

model AiCostAlert {
  id              Int      @id @default(autoincrement())
  alert_type      String   // 'daily_limit', 'spike', 'unusual_pattern'
  threshold       Float    // Umbral configurado
  current_value   Float    // Valor actual que dispar√≥ la alerta
  message         String   @db.Text
  severity        String   // 'info', 'warning', 'critical'
  resolved        Boolean  @default(false)
  resolved_at     DateTime?
  created_at      DateTime @default(now())
  
  @@index([alert_type])
  @@index([resolved])
  @@index([created_at])
  @@map("ai_cost_alerts")
}
